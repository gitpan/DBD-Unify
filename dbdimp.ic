/* Copyright (c) 1999,2000  H.Merijn Brand <h.m.brand@hccnet.nl>
 *
 * You may distribute under the terms of either the GNU General Public
 * License or the Artistic License, as specified in the Perl README file.
 *
 * Large parts of this file are shamelesly copied from other DBD drivers,
 * after which they are formatted to be readable and modified to reflect
 * the way UNIFY can work with it.
 * Main sources were Oracle (1.03), FreeTDS (0.02) and Ingres (0.24)
 *
 * Thanks to all other DBD writers ;-)
 */

#include <unistd.h>
#include <stdlib.h>
#ifndef _AIX
#  include <varargs.h>
#  endif
#include <stdio.h>
#include <ctype.h>
#include <string.h>

/* Get this from previously installed DBI module ...
 * Makefile.PL will find it's include path
 */
#define NEED_DBIXS_VERSION 7

#include <DBIXS.h>
#include <dbd_xsh.h>

#include "dbdimp.h"

/* In case the port preferred stdarg instead of varargs */
#ifdef _AIX
#  ifdef	va_start
#    undef	va_start
#    undef	va_end
#    undef	va_arg
#    endif
#  include <varargs.h>
# endif

DBISTATE_DECLARE;

/* Unify stuff off here */

#include <sqle_usr.h>

#define MAX_SQL_LEN	4096

static	byte		*sth_id_on;
static	short		n_sth_id = 4;	/* Start with max 32 $sth's */
static	int		opt_v = 0;

EXEC SQL BEGIN DECLARE SECTION;
char	u_sql_do[4096];
char	u_sql_st[4096];
char	u_sql_nm[16];
char	c_sql_nm[16];
char	o_sql_nm[16];	/* Output descriptor area	*/
char	i_sql_nm[16];	/* Input  descriptor area	*/
int	n_sql_st;

int	fix, fln, fic, ftp, fpr, fsc, fnl;
char	fnm[40], fdC[256];
short	fdS;
int	fdL;
float	fdF;
double	fdD;
EXEC SQL END   DECLARE SECTION;

long	SQLCODE;

/* VARARGS2 */
static void dbg (level, fmt, va_alist)
int  level;
char *fmt;
va_dcl
{
    auto	va_list	args;

    if (level > dbis->debug && level > opt_v)
	return;

    va_start (args);
    (void)vfprintf (DBILOGFP, fmt, args);
    (void)fflush   (DBILOGFP);
    va_end (args);
    } /* dbg */

/* ##### Unify misc stuff ################################################## */

static void NYI (func)
char *func;
{
    auto	char	die_msg[128];

    (void)sprintf (die_msg, "DBD::UNIFY::%s () is not (yet) implemented", func);
    die (die_msg);
    } /* NYI */

void dbd_init (dbistate)
dbistate_t *dbistate;
{
    DBIS = dbistate;
    /* dbis->debug = 9; */
    } /* dbd_init */

static void error (h, error_num, text, state)
SV   *h;
int  error_num;
char *text;
char *state;
{
    D_imp_xxh (h);
    sv_setiv (DBIc_ERR    (imp_xxh), (IV)error_num);
    sv_setpv (DBIc_ERRSTR (imp_xxh), text);
    unless (state)
	sv_setpv (DBIc_STATE (imp_xxh), state);
    } /* error */

static int sqlError (h)
SV *h;
{
    D_imp_xxh (h);

    auto	long	status;

    if (SQLCODE >= 0)
	return (1);

    dbg (3, "DBD::Unify::sqlError: SQLCODE = %d", SQLCODE);

    error (h, SQLCODE, ufchmsg (SQLCODE, &status), SQLSTATE);
    dbg (3, ", returning\n");
    return (0);
    } /* sqlError */

/* ##### Unify DB stuff #################################################### */

int dbd_db_login (dbh, imp_dbh, dbname, user, auth)
SV        *dbh;
imp_dbh_t *imp_dbh;
char      *dbname;
char      *user;
char      *auth;
{
    EXEC SQL BEGIN DECLARE SECTION;
    char statement[128];
    EXEC SQL END   DECLARE SECTION;
    char *opt;
    dTHR;

    dbg (2, "DBD::Unify::db_login: dbname: %s\n", dbname);

    /* CONNECT [db_name];
     *
     *	db_name:	[[dbhost]:[dbuser]:][dbpath] [dbname]
     *		$DBHOST, $DBUSER, DBPATH, $DBNAME
     *
     *	Users are implicitly checked by grants
     *
     * SET CURRENT SCHEMA TO 'USCHEMA';
     *
     *		$USCHEMA	(passed as $auth)
     */

    opt = dbname;
    /* look for options in dbname. Syntax: dbname;options */
    while (*opt && *opt != ';')
	++opt;
    if (*opt == ';') {
	*opt = 0;	/* terminate dbname */
	opt++;		/* point to options */
	}

    if (user && *user && *user != '/') {
	/* we have a username */
	dbg (3, "    user = '%s', opt = '%s' (ignored)\n", user, opt);
	}

    if (dbname && *dbname) {
	(void)sprintf (statement, "DBPATH=%s", dbname);
	(void)putenv (statement);
	}
    EXEC SQL
	CONNECT;
    dbg (3, "    After connect, sqlcode = %d\n", SQLCODE);

    unless (sqlError (dbh))
	return (0);

    DBIc_IMPSET_on (imp_dbh);	/* imp_dbh set up now                   */
    DBIc_ACTIVE_on (imp_dbh);	/* call disconnect before freeing       */

    DBIc_set (imp_dbh, DBIcf_AutoCommit, 0);
    DBIc_set (imp_dbh, DBIcf_ChopBlanks, 1);

    unless (auth && *auth)
	auth = getenv ("USCHEMA");
    if ((!user || !*user) && auth && *auth) {
	(void)sprintf (statement, "set current schema to \"%s\"", auth);
	dbg (2, "    %s\n", statement);
	EXEC SQL
	    EXECUTE IMMEDIATE :statement;
	dbg (3, "    After schema,  sqlcode = %d\n", SQLCODE);
	unless (sqlError (dbh))
	    return (0);
	}

    unless (sth_id_on = (byte *)calloc (n_sth_id, 8)) {
	error (dbh, errno, "Cannot allocate space for STH's", 0);
	return (0);
	}
    return (1);
    } /* dbd_db_login */

int dbd_db_commit (dbh, imp_dbh)
SV        *dbh;
imp_dbh_t *imp_dbh;
{
    dTHR;

    dbg (2, "DBD::Unify::db_commit\n");

    /* Check for commit () being called whilst refs to cursors
     * still exists. This needs some more thought.
     */
    if (DBIc_ACTIVE_KIDS (imp_dbh) && DBIc_WARN (imp_dbh) && !dirty) {
	warn ("DBD::Unify::db_commit (%s) invalidates %d active cursor(s)",
	    SvPV (dbh, na), (int)DBIc_ACTIVE_KIDS (imp_dbh));
	}

    EXEC SQL
	COMMIT WORK;
    return (sqlError (dbh));
    } /* dbd_db_commit */

int dbd_db_rollback (dbh, imp_dbh)
SV        *dbh;
imp_dbh_t *imp_dbh;
{
    dTHR;

    dbg (2, "DBD::Unify::db_rollback\n");

    /* Check for rollback () being called whilst refs to cursors
     * still exists. See dbd_db_commit ()
     */
    if (DBIc_ACTIVE_KIDS (imp_dbh) && DBIc_WARN (imp_dbh) && !dirty) {
	warn ("DBD::Unify::db_rollback (%s) invalidates %d active cursor(s)",
	    SvPV (dbh, na), (int)DBIc_ACTIVE_KIDS (imp_dbh));
	}

    EXEC SQL
	ROLLBACK WORK;
    return (sqlError (dbh));
    } /* dbd_db_rollback */

int dbd_db_do (dbh, statement)
SV   *dbh;
char *statement;
{
    D_imp_dbh (dbh);

    if (strlen (statement) >= MAX_SQL_LEN) {
	warn ("DBD::Unify::db_do (\"%.40s ...\") statement too long", statement);
	return (-1);
	}

    (void)strcpy (u_sql_do, statement);

    dbg (2, "DBD::Unify::db_do (\"%s\")\n", u_sql_do);

    EXEC SQL
	EXECUTE IMMEDIATE :u_sql_do;
    dbg (3, "    After execute,  sqlcode = %d\n", SQLCODE);
    unless (sqlError (dbh))
	return (-1);

    return (0);
    } /* dbd_db_do */

int dbd_db_disconnect (dbh, imp_dbh)
SV        *dbh;
imp_dbh_t *imp_dbh;
{
    int transaction_active;
    dTHR;

    dbg (2, "DBD::Unify::db_disconnect\n");

    if (DBIc_ACTIVE_KIDS (imp_dbh) && DBIc_WARN (imp_dbh) && !dirty) {
	warn ("DBD::Unify::db_disconnect (%s) invalidates %d active cursor(s)",
	    SvPV (dbh, na), (int)DBIc_ACTIVE_KIDS (imp_dbh));
	}
    DBIc_ACTIVE_off (imp_dbh);

    EXEC SQL
	DISCONNECT;
    dbg (3, "    After disconn,  sqlcode = %d\n", SQLCODE);

    /* We assume that disconnect will always work
     * since most errors imply already disconnected.
     */
    return (sqlError (dbh));
    } /* dbd_db_disconnect */

int dbd_discon_all (drh, imp_drh)
SV        *drh;
imp_drh_t *imp_drh;
{
    dTHR;

    if (!dirty && !SvTRUE (perl_get_sv ("DBI::PERL_ENDING", 0))) {
	sv_setiv (DBIc_ERR (imp_drh), (IV)1);
	sv_setpv (DBIc_ERRSTR (imp_drh), "disconnect_all not implemented");
	DBIh_EVENT2 (drh, ERROR_event, DBIc_ERR (imp_drh), DBIc_ERRSTR (imp_drh));
	return (FALSE);
	}
    if (perl_destruct_level)
	perl_destruct_level = 0;
    return (FALSE);
    } /* dbd_discon_all */

void dbd_db_destroy (dbh, imp_dbh)
SV        *dbh;
imp_dbh_t *imp_dbh;
{
    dbg (2, "DBD::Unify::db_destroy\n");

    if (DBIc_ACTIVE (imp_dbh))
	dbd_db_disconnect (dbh, imp_dbh);
    DBIc_IMPSET_off (imp_dbh);

    (void)free (sth_id_on);
    } /* dbd_db_destroy */

int dbd_db_STORE_attrib (dbh, imp_dbh, keysv, valuesv)
SV        *dbh;
imp_dbh_t *imp_dbh;
SV        *keysv;
SV        *valuesv;
{
    STRLEN kl;
    char   *key = SvPV (keysv, kl);
    SV     *cachesv = NULL;
    int    on = SvIV (valuesv);

    if (kl == 10 && strEQ (key, "AutoCommit")) {
	DBIc_set (imp_dbh, DBIcf_AutoCommit, 0);	/* Allways off	*/
	return (TRUE);
	}
    if (kl ==  9 && strEQ (key, "ScanLevel")) {
	dbg (2, "DBD::Unify::dbd_db_STORE (ScanLevel = %d)\n", on);
	if (on < 1 || on > 16)
	    return (FALSE);
	(void)sprintf (u_sql_do, "set transaction scan level %d", on);
	EXEC SQL
	    EXECUTE IMMEDIATE :u_sql_do;
	dbg (3, "    After SCANLVL,  sqlcode = %d\n", SQLCODE);
	unless (sqlError (dbh))
	    return (FALSE);
	return (TRUE);
	}

    return (FALSE);
    } /* dbd_db_STORE_attrib */

SV *dbd_db_FETCH_attrib (dbh, imp_dbh, keysv)
SV        *dbh;
imp_dbh_t *imp_dbh;
SV        *keysv;
{
    STRLEN kl;
    char   *key = SvPV (keysv, kl);
    int    i;
    SV     *retsv = NULL;
    /* Default to caching results for DBI dispatch quick_FETCH  */
    int    cacheit = TRUE;

    if (kl == 10 && strEQ (key, "AutoCommit")) {
	retsv = newSVsv (boolSV (0));
	return (retsv);
	}

    return (Nullsv);
    } /* dbd_db_FETCH_attrib */

/* ##### Unify ST stuff #################################################### */

static short new_sth_id (dbh)
SV *dbh;
{
    register	short	i;
    register	short	b;

    for (i = 0; i < n_sth_id; i++) {
	for (b = 0; b < 7; b++) {
	    unless (sth_id_on[i] & (1 << b)) {
		sth_id_on[i] |= (1 << b);
		return (i * 8 + b + 1);
		}
	    }
	}
    i = n_sth_id + 4;
    if (sth_id_on = realloc (sth_id_on, i * 8)) {
	b = n_sth_id * 8 + 1;
	while (n_sth_id < i)
	    sth_id_on[n_sth_id++] = (byte)0;
	return (b);
	}
    error (dbh, errno, "Cannot allocate extra space for STH's", 0);
    return (0);
    } /* new_sth_id */

static short clr_sth_id (dbh, id)
SV *dbh;
short id;
{
    if (id <= 0 || id > n_sth_id * 8) {
	error (dbh, 0, "Cannot clr invalid statement ID", 0);
	return (0);
	}
    id--;
    unless (sth_id_on[id / 8] & (1 << (id % 8))) {
	error (dbh, 0, "Cannot clr statement ID already cleared (threading?)", 0);
	return (0);
	}
    sth_id_on[id / 8] &= ~(1 << (id % 8));
    return (1);
    } /* set_sth_id */

static int use_sth_id (dbh, id)
SV *dbh;
short id;
{
    if (id <= 0 || id > n_sth_id * 8) {
	error (dbh, 0, "Cannot use invalid statement ID", 0);
	return (0);
	}
    id--;
    unless (sth_id_on[id / 8] & (1 << (id % 8))) {
	error (dbh, 0, "Cannot use statement ID", 0);
	return (0);
	}
    (void)sprintf (u_sql_nm, "u_sql_st_%06d", id);
    (void)sprintf (c_sql_nm, "c_sql_st_%06d", id);
    (void)sprintf (o_sql_nm, "o_sql_st_%06d", id);
    (void)sprintf (i_sql_nm, "i_sql_st_%06d", id);
    return (1);
    } /* use_sth_id */

int dbd_st_prepare (sth, imp_sth, statement, attribs)
SV        *sth;
imp_sth_t *imp_sth;
char      *statement;
SV        *attribs;   /* unused */
{
    SV *dbh = DBIc_PARENT_H (imp_sth);
    D_imp_dbh_from_sth;

    if (strlen (statement) >= MAX_SQL_LEN) {
	warn ("DBD::Unify::st_prepare (\"%.40s ...\") statement too long",
	    statement);
	return (-1);
	}

    unless (imp_sth->id = new_sth_id (dbh))
	return (-1);

    unless (use_sth_id (dbh, imp_sth->id))
	return (-1);
    dbg (2, "DBD::Unify::st_prepare %s (\"%s\")\n", u_sql_nm, statement);
    if (imp_sth->statement = (char *)malloc (strlen (statement) + 2))
	(void)strcpy (imp_sth->statement, statement);

    EXEC SQL
	ALLOCATE   :c_sql_nm
	CURSOR FOR :u_sql_nm;
    if (SQLCODE == -2061)	/* Cannot deallocate allocated cursor, so  */
	SQLCODE = 0;		/* re-use it (it'll be the same context)   */
    dbg (3, "    After declare,  sqlcode = %d\n", SQLCODE);
    unless (sqlError (dbh))
	return (-1);

    (void)strcpy (u_sql_st, statement);
    EXEC SQL
	PREPARE :u_sql_nm
	FROM    :u_sql_st;
    dbg (3, "    After prepare,  sqlcode = %d\n", SQLCODE);
    unless (sqlError (dbh))
	return (-1);

    EXEC SQL
	ALLOCATE SQL DESCRIPTOR :o_sql_nm
	WITH MAX 128;
    dbg (3, "    After allocate, sqlcode = %d\n", SQLCODE);
    unless (sqlError (dbh))
	return (-1);

    EXEC SQL
	DESCRIBE OUTPUT      :u_sql_nm
	USING SQL DESCRIPTOR :o_sql_nm;
    dbg (3, "    After describe, sqlcode = %d\n", SQLCODE);
    unless (sqlError (dbh))
	return (-1);

    EXEC SQL
	GET   SQL DESCRIPTOR :o_sql_nm
	:n_sql_st = COUNT;
    dbg (3, "    After count,    sqlcode = %d, count = %d\n", SQLCODE, n_sql_st);
    unless (sqlError (dbh))
	return (-1);
    DBIc_NUM_FIELDS (imp_sth) = n_sql_st;

    /* Check for positional poarameters */
    {   register char	*src = statement;
        auto	 int	in_lit = 0;	/* inside "..."		*/
        auto	 int	in_str = 0;	/* inside '...'		*/
        auto	 int	in_cmt = 0;	/* inside comment	*/
        while(*src) {
            if (*src == '"'  && !in_str && !in_cmt)
                in_lit = ~in_lit;
            else
            if (*src == '\'' && !in_lit && !in_cmt)
                in_str = ~in_str;
            else
            if (*src == '/' && src[1] == '*' && !in_lit && !in_str)
                in_cmt = 1;
            else
            if (in_cmt && *src == '*' && src[1] == '/')
                in_cmt = 0;
            if ((*src == '?') && !in_lit && !in_str && !in_cmt)
                DBIc_NUM_PARAMS (imp_sth)++;
            src++;
	    }
	}
    if ((n_sql_st = DBIc_NUM_PARAMS (imp_sth)) > 0) {
	EXEC SQL
	    ALLOCATE SQL DESCRIPTOR :i_sql_nm
	    WITH MAX                :n_sql_st;
	dbg (3, "    After allocate, sqlcode = %d\n", SQLCODE);
	unless (sqlError (dbh))
	    return (-1);

	EXEC SQL
	    DESCRIBE INPUT          :u_sql_nm
	    USING    SQL DESCRIPTOR :i_sql_nm;
	dbg (3, "    After describe, sqlcode = %d\n", SQLCODE);
	unless (sqlError (dbh))
	    return (-1);
	}

    dbg (2, "DBD::Unify::st_prepare %s (<= %d, => %d)\n", u_sql_nm,
	DBIc_NUM_FIELDS (imp_sth), DBIc_NUM_PARAMS (imp_sth));

    DBIc_IMPSET_on (imp_sth);
    return (1);
    } /* dbd_st_prepare */

int dbd_bind_ph (sth, imp_sth, param, value, sql_type, attribs,
		 is_inout, maxlen)
SV        *sth;
imp_sth_t *imp_sth;
SV        *param;
SV        *value;
IV        sql_type;
SV        *attribs;
int       is_inout;
IV        maxlen;
{
    int   num_fields, i;
    AV    *av;
    SV    *dbh = DBIc_PARENT_H (imp_sth);

    int   ch;

    D_imp_dbh_from_sth;

    unless (use_sth_id (dbh, imp_sth->id))
	return (-1);
    dbg (2, "DBD::Unify::st_bind %s\n", u_sql_nm);

    unless (SvNIOK (param))
        croak ("DBD::Unify::st_bind: parameter not a number");

    fix = (int)SvIV (param);
    if (fix < 1 || fix > DBIc_NUM_PARAMS (imp_sth))
        croak ("DBD::Unify::st_bind: parameter outside range 1..%d",
            DBIc_NUM_PARAMS (imp_sth));


    dbg (3, "     Field %3d: ", fix);
    EXEC SQL
	GET DESCRIPTOR :i_sql_nm
	VALUE :fix
	      :ftp = TYPE,
	      :fln = LENGTH,
	      :fpr = PRECISION,
	      :fsc = SCALE,
	      :fnl = NULLABLE,
	      :fnm = NAME;
    unless (sqlError (dbh))
	return (-1);

    dbg (4, "[%02X %02X %02X %02X %02X] ",
	(unsigned char)ftp, fln, fpr, fsc, fic);
    dbg (3, "%-.8s: ", fnm);

    if (!SvOK (value)) {	/* NULL		*/
	dbg (3, "NULL");
	EXEC SQL
	    SET SQL DESCRIPTOR :i_sql_nm
	    VALUE :fix
		INDICATOR = -1;
	unless (sqlError (dbh))
	    return (-1);
	}
    else {
	switch (ftp) {
	    case SQLCHAR: {
		auto	STRLEN	l;
		auto	char	*s;

		dbg (3, "CHAR%6d: ", fln);
		s = SvPV (value, l);
		if (l > fln)
		    croak ("DBD::Unify::st_bind: string too long (%d > %d)",
			l, fln);

		(void)sprintf (fdC, "%-*.*s", fln, fln, s);
		EXEC SQL
		    SET SQL DESCRIPTOR :i_sql_nm
		    VALUE :fix
			DATA      = :fdC,
			INDICATOR = 0;
		unless (sqlError (dbh))
		    return (-1);
		break;
		}

	    case SQLFLOAT:
		dbg (3, "FLOAT %2d.%1d: ", fln, fpr);
		unless (SvNOK (value))
		    croak ("DBD::Unify::st_bind: need float");

		fdF = (float)SvNV (value);
		EXEC SQL
		    SET SQL DESCRIPTOR :i_sql_nm
		    VALUE :fix
			DATA      = :fdF,
			INDICATOR = 0;
		unless (sqlError (dbh))
		    return (-1);
		break;

	    case SQLREAL:
	    case SQLDBLPREC:
		dbg (3, "DOUBL %1d.%2d: ", fln, fpr);
		unless (SvNOK (value))
		    croak ("DBD::Unify::st_bind: need double");

		fdD = (double)SvNV (value);
		EXEC SQL
		    SET SQL DESCRIPTOR :i_sql_nm
		    VALUE :fix
			DATA      = :fdD,
			INDICATOR = 0;
		unless (sqlError (dbh))
		    return (-1);
		break;

	    case SQLAMOUNT:
		dbg (3, "AMNT   %d.%d: ", fpr, fsc);
		unless (SvNOK (value))
		    croak ("DBD::Unify::st_bind: need float");

		fdF = (float)SvNV (value);
		EXEC SQL
		    SET SQL DESCRIPTOR :i_sql_nm
		    VALUE :fix
			DATA      = :fdF,
			INDICATOR = 0;
		unless (sqlError (dbh))
		    return (-1);
		break;

	    case SQLHUGEAMT:
		dbg (3, "HAMNT  %d.%d: ", fpr, fsc);
		unless (SvNOK (value))
		    croak ("DBD::Unify::st_bind: need double");

		fdD = (double)SvNV (value);
		EXEC SQL
		    SET SQL DESCRIPTOR :i_sql_nm
		    VALUE :fix
			DATA      = :fdD,
			INDICATOR = 0;
		unless (sqlError (dbh))
		    return (-1);
		break;

	    case SQLDATE:
	    case SQLSMTIME:
	    case SQLTEXT:
	    case SQLBINARY:
	    case SQLHDATE:
	    case SQLBYTE:
		dbg (3, "TYPE %2d: NYI", ftp);
		NYI ("st_bind[date/time/text/binary]");
		break;

	    case SQLNUMERIC:
	    case SQLDECIMAL:
	    case SQLINTEGER:
		dbg (3, "NUMERIC %2d: ", fpr);
		unless (SvIOK (value))
		    croak ("DBD::Unify::st_bind: need integer");

		fdL = (int)SvIV (value);
		EXEC SQL
		    SET SQL DESCRIPTOR :i_sql_nm
		    VALUE :fix
			DATA      = :fdL,
			INDICATOR = 0;
		unless (sqlError (dbh))
		    return (-1);
		break;

	    case SQLSMINT:
		unless (SvIOK (value))
		    croak ("DBD::Unify::st_bind: need integer");

		fdS = (short)SvIV (value);
		EXEC SQL
		    SET SQL DESCRIPTOR :i_sql_nm
		    VALUE :fix
			DATA      = :fdS,
			INDICATOR = 0;
		unless (sqlError (dbh))
		    return (-1);
		break;

	    case SQLNOTYPE:
		dbg (3, "NO TYPE");
		break;

	    default:
		croak ("DBD::Unify::st_bind: "
		    "unknown field type %d for field '%s'\n",
			ftp, fnm);
	    }
	}
    dbg (3, " ==\n");

    return (1);
    } /* dbd_bind_ph */

int dbd_st_execute (sth, imp_sth)
SV        *sth;
imp_sth_t *imp_sth;
{
    SV *dbh = DBIc_PARENT_H (imp_sth);

    dTHR;
    D_imp_dbh_from_sth;

    unless (use_sth_id (dbh, imp_sth->id))
	return (-1);
    dbg (2, "DBD::Unify::st_execute %s\n", u_sql_nm);

    if (DBIc_NUM_FIELDS (imp_sth) == 0) {
	/* non-select statement: just execute it */
	dbg (2, "DBD::Unify::st_execute - non-select\n");

	if (DBIc_NUM_PARAMS (imp_sth) > 0) {
	    EXEC SQL
		EXECUTE              :u_sql_st
		USING SQL DESCRIPTOR :i_sql_nm;
	    }
	else {
	    EXEC SQL
		EXECUTE              :u_sql_st;
	    }
	dbg (3, "    After execute,  sqlcode = %d\n", SQLCODE);
	return (sqlError (sth));
	}

    if (DBIc_NUM_PARAMS (imp_sth) > 0) {
	EXEC SQL
	    OPEN                 :c_sql_nm
	    USING SQL DESCRIPTOR :i_sql_nm;
	}
    else {
	EXEC SQL
	    OPEN                 :c_sql_nm;
	}
    dbg (3, "    After open,     sqlcode = %d\n", SQLCODE);
    unless (sqlError (dbh))
	return (-1);

    DBIc_ACTIVE_on (imp_sth);
    return (0);
    } /* dbd_st_execute */

AV *dbd_st_fetch (sth, imp_sth)
SV        *sth;
imp_sth_t *imp_sth;
{
    int    num_fields, i;
    AV     *av;
    SV     *dbh = DBIc_PARENT_H (imp_sth);

    D_imp_dbh_from_sth;

    unless (use_sth_id (dbh, imp_sth->id))
	return (Nullav);
    dbg (2, "DBD::Unify::st_fetch %s\n", u_sql_nm);

    unless (DBIc_ACTIVE (imp_sth)) {
	error (sth, -7, "fetch without open cursor", 0);
	return (Nullav);
	}

    EXEC SQL
	WHENEVER NOT FOUND GOTO :u_sql_st_end;

    EXEC SQL
	FETCH                :c_sql_nm
	USING SQL DESCRIPTOR :o_sql_nm;

    av = DBIS->get_fbav (imp_sth);
    num_fields = AvFILL (av) + 1;

    dbg (3, "    Fetched         sqlcode = %d, fields = %d\n",
	SQLCODE, num_fields);

    unless (av_len (av) + 1 == num_fields) {
	int ro = SvREADONLY (av);
	if (ro)
	    SvREADONLY_off (av);
	for (i = av_len (av) + 1; i < num_fields; i++)
	    av_store (av, i, newSV (0));
	if (ro)
	    SvREADONLY_on (av);
	}

    for (fix = 1; fix <= num_fields; fix++) {
	int       ch;
	SV        *sv = AvARRAY(av)[fix - 1];

	SvREADONLY_off (sv);

	dbg (3, "     Field %3d: ", fix);
	EXEC SQL
	    GET DESCRIPTOR :o_sql_nm
	    VALUE :fix
		  :ftp = TYPE,
		  :fln = LENGTH,
		  :fpr = PRECISION,
		  :fic = INDICATOR,
		  :fsc = SCALE,
		  :fnl = NULLABLE,
		  :fnm = NAME;
	unless (sqlError (dbh))
	    return (Nullav);

	dbg (4, "[%02X %02X %02X %02X %02X] ",
	    (unsigned char)ftp, fln, fpr, fsc, fic);
	dbg (3, "%-.8s: ", fnm);
	if (fic == -1) {	/* NULL		*/
	    (void)SvOK_off (sv);
	    dbg (3, "NULL");
	    }
	else {
	    switch (ftp) {
		case SQLCHAR:
		    dbg (3, "CHAR%6d: ", fln);
		    EXEC SQL
			GET DESCRIPTOR :o_sql_nm
			VALUE :fix
			      :fdC = DATA;
		    unless (sqlError (dbh))
			return (Nullav);
		    i = fln;
		    if (DBIc_has (imp_sth, DBIcf_ChopBlanks)) {
			while (i && (!fdC[i - 1] || fdC[i - 1] == ' '))
			    i--;
			}
		    fdC[i] = (char)0;
		    dbg (3, "(%d)'%s' ", i, fdC);
		    sv_setpvn (sv, fdC, i);
		    dbg (3, "\"%s\"", SvPVX (sv));
		    break;

		case SQLFLOAT:
		    dbg (3, "FLOAT %2d.%1d: ", fln, fpr);
		    EXEC SQL
			GET DESCRIPTOR :o_sql_nm
			VALUE :fix
			      :fdF = DATA;
		    unless (sqlError (dbh))
			return (Nullav);
		    sv_setnv (sv, (double)fdF);
		    dbg (3, "%lf", SvNV (sv));
		    break;

		case SQLREAL:
		case SQLDBLPREC:
		    dbg (3, "DOUBL %1d.%2d: ", fln, fpr);
		    EXEC SQL
			GET DESCRIPTOR :o_sql_nm
			VALUE :fix
			      :fdD = DATA;
		    unless (sqlError (dbh))
			return (Nullav);
		    sv_setnv (sv, fdD);
		    dbg (3, "%lf", SvNV (sv));
		    break;

		case SQLAMOUNT:
		    dbg (3, "AMNT   %d.%d: ", fpr, fsc);
		    EXEC SQL
			GET DESCRIPTOR :o_sql_nm
			VALUE :fix
			      :fdF = DATA;
		    unless (sqlError (dbh))
			return (Nullav);
		    sv_setnv (sv, (double)fdF);
		    dbg (3, "%lf", SvNV (sv));
		    break;

		case SQLHUGEAMT:
		    dbg (3, "HAMNT  %d.%d: ", fpr, fsc);
		    EXEC SQL
			GET DESCRIPTOR :o_sql_nm
			VALUE :fix
			      :fdD = DATA;
		    unless (sqlError (dbh))
			return (Nullav);
		    sv_setnv (sv, fdD);
		    dbg (3, "%lf", SvNV (sv));
		    break;

		case SQLDATE:
		case SQLSMTIME:
		case SQLTEXT:
		case SQLBINARY:
		case SQLHDATE:
		case SQLBYTE:
		    dbg (3, "TYPE %2d: NYI", ftp);
		    (void)SvOK_off (sv);
		    break;

		case SQLNUMERIC:
		case SQLDECIMAL:
		case SQLINTEGER:
		    dbg (3, "NUMERIC %2d: ", fpr);
		    EXEC SQL
			GET DESCRIPTOR :o_sql_nm
			VALUE :fix
			      :fdL = DATA;
		    unless (sqlError (dbh))
			return (Nullav);
		    dbg (3, "(%ld) ", fdL);
		    sv_setiv (sv, fdL);
		    dbg (3, "%ld", SvIV (sv));
		    break;

		case SQLSMINT:
		    dbg (3, "NUMERIC %2d: ", fpr);
		    EXEC SQL
			GET DESCRIPTOR :o_sql_nm
			VALUE :fix
			      :fdS = DATA;
		    unless (sqlError (dbh))
			return (Nullav);
		    dbg (3, "(%d) ", fdS);
		    sv_setiv (sv, (int)fdS);
		    dbg (3, "%ld", SvIV (sv));
		    break;

		case SQLNOTYPE:
		    dbg (3, "NO TYPE");
		    (void)SvOK_off (sv);
		    break;

		default:
		    croak ("DBD::Unify::st_fetch: "
			"unknown field type %d for field '%s'\n",
			    ftp, fnm);
		}
	    }
	dbg (3, " ==\n");
	}

    dbg (3, "     Fetch done\n");
    return (av);

u_sql_st_end:

    dbg (3, "     Fetch done (end of scan)\n");
    return (Nullav);
    } /* dbd_st_fetch */

int dbd_st_rows (sth, imp_sth)
SV        *sth;
imp_sth_t *imp_sth;
{
    NYI ("st_rows");
    return (0);

#ifdef NOTYET
    EXEC SQL BEGIN DECLARE SECTION;
    int rowcount;
    EXEC SQL END   DECLARE SECTION;

    dbg (2, "DBI::Unify::st_rows\n");

    rowcount = 0;
    /* Find which table I'm using in sth */
    /*
    EXEC SQL
	SELECT count (*)
	FROM  :table
	INTO  :rowcount;
    dbg (2, "rowcount = %d\n", rowcount);
    unless (sqlError (sth))
	return (-1);
    */
    return (rowcount);
#endif
    } /* dbd_st_rows */

int dbd_st_finish (sth, imp_sth)
SV        *sth;
imp_sth_t *imp_sth;
{
    SV *dbh = DBIc_PARENT_H (imp_sth);
    dTHR;

    unless (use_sth_id (dbh, imp_sth->id))
	return (-1);
    dbg (3, "DBD::Unify::st_finish %s\n", u_sql_nm);

    if (DBIc_ACTIVE (imp_sth)) {
	EXEC SQL
	    CLOSE :c_sql_nm;
	dbg (3, "    After close,    sqlcode = %d\n", SQLCODE);
	unless (sqlError (dbh))
	    return (-1);

	/*
	EXEC SQL
	    DEALLOCATE PREPARE    :c_sql_nm;
	dbg (3, "    After deallocC, sqlcode = %d\n", SQLCODE);
	unless (sqlError (dbh))
	    return (-1);
	*/

	EXEC SQL
	    DEALLOCATE DESCRIPTOR :o_sql_nm;
	dbg (3, "    After deallocO, sqlcode = %d\n", SQLCODE);
	unless (sqlError (dbh))
	    return (-1);

	if (DBIc_NUM_PARAMS (imp_sth) > 0) {
	    EXEC SQL
		DEALLOCATE DESCRIPTOR :i_sql_nm;
	    dbg (3, "    After deallocI, sqlcode = %d\n", SQLCODE);
	    unless (sqlError (dbh))
		return (-1);
	    }

	EXEC SQL
	    DEALLOCATE PREPARE    :u_sql_nm;
	dbg (3, "    After deallocU, sqlcode = %d\n", SQLCODE);
	unless (sqlError (dbh))
	    return (-1);

	DBIc_ACTIVE_off (imp_sth);
	}

    if (imp_sth->statement) {
	(void)free (imp_sth->statement);
	imp_sth->statement = (char *)0;
	}
    return (clr_sth_id (dbh, imp_sth->id));
    } /* dbd_st_finish */

void dbd_st_destroy (sth, imp_sth)
SV        *sth;
imp_sth_t *imp_sth;
{
    dTHR;
    D_imp_dbh_from_sth;

    dbg (2, "DBD::Unify::st_destroy\n");

    if (DBIc_ACTIVE (imp_sth)) {
	/* DBIc_ACTIVE_off (imp_sth); */
	warn ("DBD::Unify::st_destroy: Handle still active, will finish first\n");
	dbd_st_finish (sth, imp_sth);
	}
    if (DBIc_has (imp_sth, DBIcf_IMPSET))
	DBIc_IMPSET_off (imp_sth);
    } /* dbd_st_destroy */

int dbd_st_blob_read (sth, imp_sth, field, offset, len, destrv, destoffset)
SV        *sth;
imp_sth_t *imp_sth;
int       field;
long      offset;
long      len;
SV        *destrv;
long      destoffset;
{
    NYI ("st_blob_read");
    return (0);
    } /* dbd_st_blob_read */

int dbd_st_STORE_attrib (sth, imp_sth, keysv, valuesv)
SV        *sth;
imp_sth_t *imp_sth;
SV        *keysv;
SV        *valuesv;
{
    STRLEN kl;
    char   *key = SvPV (keysv,kl);
    SV     *cachesv = NULL;
    int    on = SvTRUE (valuesv);
    dTHR;

    /*
    dbg (3, "DBD::Unify::st_STORE(%s)->{%s}\n", imp_sth->name, key);
    */

    NYI ("st_STORE_attrib");
    return (FALSE); /* no values to store */
    } /* dbd_st_STORE_attrib */

SV *dbd_st_FETCH_attrib (sth, imp_sth, keysv)
SV        *sth;
imp_sth_t *imp_sth;
SV        *keysv;
{
    STRLEN kl;
    char   *key = SvPV (keysv, kl);
    int    i;
    SV     *retsv = NULL;
    int    cacheit = TRUE;

    if (kl == 13 && strEQ (key, "NUM_OF_PARAMS"))	/* handled by DBI */
	return (Nullsv);	

    i = DBIc_NUM_FIELDS (imp_sth);

#ifdef NOTYET
    if (kl == 11 && strEQ (key, "uni_lengths")) {
	AV *av = newAV ();
	retsv = newRV (sv_2mortal ((SV*)av));
	while (--i >= 0)
	    av_store (av, i, newSViv ((IV)imp_sth->fbh[i].disize));
	}
    else
    if (kl == 9 && strEQ (key, "uni_types")) {
	AV *av = newAV ();
	retsv = newRV (sv_2mortal ((SV*)av));
	while (--i >= 0)
	    av_store (av, i, newSViv (imp_sth->fbh[i].dbtype));
	}
    else
    if (kl == 4 && strEQ (key, "TYPE")) {
	AV *av = newAV ();
	retsv = newRV (sv_2mortal ((SV*)av));
	while (--i >= 0)
	    av_store (av, i, newSViv (ora2sql_type (imp_sth->fbh[i].dbtype)));
	}
    else
    if (kl == 5 && strEQ (key, "SCALE")) {
	AV *av = newAV ();
	retsv = newRV (sv_2mortal ((SV*)av));
	while (--i >= 0)
	    av_store (av, i, newSViv (imp_sth->fbh[i].scale));
	}
    else
    if (kl == 9 && strEQ (key, "PRECISION")) {
	AV *av = newAV ();
	retsv = newRV (sv_2mortal ((SV*)av));
	while (--i >= 0)
	    av_store (av, i, newSViv (imp_sth->fbh[i].prec));
	}
    else
#ifdef ORACLE
    if (kl == 9 && strEQ (key, "uni_rowid")) {
	/* return current _binary_ ROWID (oratype 11) uncached	*/
	/* Use { ora_type => 11 } when binding to a placeholder	*/
	retsv = newSVpv ((char*)&imp_sth->cda->rid, sizeof (imp_sth->cda->rid));
	cacheit = FALSE;
	}
    else
    if (kl == 17 && strEQ (key, "uni_est_row_width")) {
	retsv = newSViv(imp_sth->est_width);
	cacheit = TRUE;
	}
    else
#endif
    if (kl == 4 && strEQ (key, "NAME")) {
	AV *av = newAV ();
	retsv = newRV (sv_2mortal ((SV*)av));
	while (--i >= 0)
	    av_store (av, i, newSVpv ((char*)imp_sth->fbh[i].name, 0));
	}
    else
    if (kl == 8 && strEQ (key, "NULLABLE")) {
	AV *av = newAV ();
	retsv = newRV (sv_2mortal ((SV*)av));
	while (--i >= 0)
	    av_store (av, i, boolSV (imp_sth->fbh[i].nullok));
	}
    else
#endif
	return (Nullsv);

    if (cacheit) { /* cache for next time (via DBI quick_FETCH)	*/
	SV **svp = hv_fetch ((HV*)SvRV(sth), key, kl, 1);
	sv_free (*svp);
	*svp = retsv;
	(void)SvREFCNT_inc (retsv);	/* so sv_2mortal won't free it	*/
	}
    return (sv_2mortal (retsv));
    } /* dbd_st_FETCH_attrib */
